# 2부 벽돌부터 시작하기 : 프로그래밍 패러다임

## 무엇을 공부할까

### 프로그래밍 패러다임

3장 패러다임 개요

	__구조적 프로그래밍

	__객체 지향 프로그래밍

	__함수형 프로그래밍

	__생각할 거리

	__결론

4장 구조적 프로그래밍 4장

	...

5장 객체 지향 프로그래밍 8장

	...

6장 함수형 프로그래밍 4

	...
	
---------------------------------------
## 프로그래밍 패러다임
```
소프트웨어 아키텍처는 코드로 부터 시작한다.
따라서 아키텍처에 대한 논의도 코드가 최초로 작성된 시점부터, 우리가 코드를 통해 배운 내용을 살펴보는데서 출발하고자 한다.
```

1. **프로그램을 단순히 데이터**라고 이해
2. 사람이 식별할 수 있는 형태 (반복, 분기, 할당, 서브루틴, 스택) 바이너리 언어를 사용
3. 어셈블러 등장
4. 컴파일러 개발
5. [포트란](https://ko.wikipedia.org/wiki/%ED%8F%AC%ED%8A%B8%EB%9E%80) 개발로 인한 다양한 프로그래밍 언어 등장

#### 생각해볼만한 주제
- 왜 아키텍쳐 책에서 패러다임을 설명할까?

```
패러다임이란 프로그래밍을 하는 방법으로, 대체로 언어에 독립적이다.
패러다임이 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용해야 하는지를 결정한다.
...
현재까지 세가지의 패러다임이 존재하고, 이 외의 패러다임은 존재하지 않는다.
```

---------------------------------------

## 패러다임 개요

### 구조적 프로그래밍
[wiki](https://ko.wikipedia.org/wiki/%EA%B5%AC%EC%A1%B0%EC%A0%81_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
```
최초로 적용된 패러다임(최초로 만들어진 패러다임은 아닌)은 구조적 프로그래밍으로 다익스트라가 개발
...
무분별한 goto 문장은 해롭다. 이러한 구조를 if/then/else, do/while/until과 같이 더 익숙한 구조로 대체했다.
...
★구조적 프로그래밍은 제어흐름의 직접적인 전환에 대한 규칙을 부과한다.
```


### 객체 지향 프로그래밍


```
ALGOL 언어의 함수 호출 스택 프레임을 힙으로 옮기면서, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지 될 수 있음을 발견했다.
바로 이러한 함수가 클래스의 생성자가 되었고, 지역변수는 인스턴스 변수, 그리고 중첩함수는 매서드가 되었다.
함수 포인트를 특정 규칙에 따라 사용하는 과정을 통해 필연적으로 다형성이 등장하게 되었다.
...
★ 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대한 규칙을 부과한다.
```

### 함수형 프로그래밍
[함수형프로그래밍](https://velog.io/@kyusung/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9A%94%EC%95%BD)
```
가장 먼저 만들어진 프로그래밍, 함수형 프로그래밍은 컴퓨터 프로그래밍 자체보다 먼저 등장했다.
함수프로그래밍은 람다 계산법에 영향을 받아 만들어졌다.
람다 계산법의 기초가 되는 개념은 불변성으로 심볼의 값이 변경되지 않는다는 개념이다.
이는 함수형 언어에서 할당문이 전혀 없다는 뜻이기도 하다
...
★ 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
```
[LISP](https://ko.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%ED%94%84)


### 생각할 거리

```
각 패러다임은 프로그래머에게서 권한을 박탈한다. 어느 패러다임도 새로운 권한을 부여하지 않는다.
각 패러다임은 부정적인 의도를 가지는 일종의 추가적인 규칙을 부과한다.
즉, 패러다임은 무엇을 해야 할지를 말하기 보다는 무엇을 해서는 안 되는지를 말해준다. (goto, 함수 포인터, 할당문)
...
우리에게 가져갈 수 있는건 더이상 없다.
```

### 결론
```
패러다임의 역사로부터 얻을 수 있는 이러한 교훈은 아키텍처와 관계가 있다.
우리는 경계를 넘나들기 위한 매커니즘으로 다형성을 이용한다.
우리는 함수형 프로그래밍을 이용하여 데이터의 위치와 접근 방법에 대한 규칙을 부과한다.
우리는 모듈의 기반 알고리즘으로 구조적 프로그래밍을 사용한다
세 가지 패러다임과 아키텍처의 세 가지 큰 관심사가 어떻게 서로 연관되는지에 주목하자.
```
Q1. 우리는 함수형 프로그래밍을 이용하여 **데이터의 위치**와 접근 방법에 대한 규칙을 부과한다.
- 여기서 말하는 데이터의 위치란 할당문을 함수내에 선언하지 않으면서 데이터의 메모리상 위치를 말할까?


Q2. 모듈 기반 알고리즘 이란?


---------------------------------------
## 구조적 프로그래밍

```
[요약]
다익스트라라는 사람이 있었다. 이사람은 똑똑했고 프로그래밍에 도전을 한다.
프로그래머라는 직업을 인정받지 못하고, 이론 물리학자로 인정 받았다.
프로그래밍의 원리나 과학을 증명한 사람이 아무도 없으므로 자신의 직업 인정받지 못할꺼라 우려했고,
소프트웨어를 과학으로 발전 시키려고 했다.
진공관 컴퓨터는 쓰면서 뭔가 위대한 발견을 했다.
```

### 증명
```
[요약]
초반엔 프로그래밍이 너무 어려웠다. 너무 많은 세부사항이 필요했다.
다익스트라는 증명이라는 수학적인 원리를 적용하여 이 문제를 해결하고자 했다.
그의 비전은 공리, 정리, 따름정리, 보조정리로 구성되는 유클리드 계증구조를 만드는 것이었다.
...
이들 구조를 코드와 결합시키며, 그래서 코드가 올바르다는 사실을 스스로 증명하게 되는 방식이었다.
```
- 공리 : 증명없이 참으로 받아들이는 명제
- 정리 : 증명이라는 과정을 통해 참이라는 것이 밝혀진 명제다.
- 보조정리 : 정리를 증명하는데 필요한 정리
- 따름정리 : 정리를 통해 자연스럽게 도출되는 정리를따름정리 

- goto 문장 이 모듈을 더 작은 단위로 분해하는 과정에 방해
- 분할안되면 분할 정복 접근법 사용 불가
- 문제가 발생하지 않는 경우도 있었다.

```
모든 프로그램을 순차, 분기, 반복이라는 3가지 구조만으로 표현할 수 있다는 사실을 발견했다.
...
즉, 모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실이었다.
```

### 해로운 성명서

3줄요약
1. goto문이 해롭다고 싸웠다.
2. goto문이 해롭다고 결정났다.
3. goto문 지원 안한다.

```
현재 우리 모두는 구조적 프로그래머이며, 선택의 여지가 없다.
제어흐름을 제약없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문이다.
```

### 기능적 분해
```
구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.
...
이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용하여 표현할 수 있다.
```

### 엄밀한 증명은 없었다.
1. 끝내 증명은 이루어지지 않았다.
2. 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않았다.
3. 이 증명법 말고 다른 증명법도 있다. (과학적 방법)

### 과학이 구출하다.
```
과학은 근본적으로 수학과는 다른데,과학 이론과 법칙은 그 올바름을 절대 증명할 수 없기 때문이다.
...
과학적 방법은 방증은 가능하지만 증명은 불가능하다.
...
결론적으로 수학은 증명 가능한 서술이 참임을 입증하는 원리라고 볼 수 있다. 반면 과학은 증명 가능한 서술이 거짓임을 입증하는 원리라고 볼 수 있다.
```

### 테스트 
```
"테스트는 버그가 있음을 보여줄 뿐, 버그가 없을을 보여줄수는 없다."
수학적인 구조를 다루는 듯 보이더라도, 소프트웨어 개발은 수학적인 시도가 아니라는 사실이다.
오히려 과학에 가깝다. 최선을 다하더라도 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문이다.
...
구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다.
```

### 결론
```
구조적 프로그래밍이 오늘까지 가치가 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문이다.
...
가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다.
소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 만들기 위해 분주히 노력해야 한다. 
이를 위해 구조적 프로그래밍과 유사한 제한적인 규칙들을 받아들여 활용해야 한다.
```

---------------------------------------
## 객체 지향 프로그래밍

```
좋은 아키텍처를 만드는 일은 객체지향, __ 설계 원칙을 이해하고 응용하는 데서 출발한다.
함수 호출 스택 프레임을 힙으로 옮기고 __를 발명한...
__란 무엇인가?
1. 데이터와 함수의 조합
2. 실제 세계를 모델링하는 새로운 방법
```

### 캡슐화
말할 내용 : 왜 캡슐화가 __를 정의하는 요소가 되지 못하는가

```
사람들은 __을 정의하는 요소중에 하나로 캡슐화를 언급한다.
그러나 __에서만 국한된 개념이 아니다. C 언어에서도 캡슐화가 가능하다.
```

**39p**
```
point.h를 사용하는 측에서 struct Point 멤버에 접근할 방법이 전혀없다.
사용자는 함수를 호출할 수는 있지만, 내부 구현을 알 수 없다.
...
먼저 데이터 구조와 함수를 헤더 파일에 선언하고, 구현 파일에서 이들을 구현햇다.
이후에 C++라는 형태로 __가 등장했고 C가 제공하는 완전한 캡슐화는 깨지게 되었다.
```
- __말고 다른 언어도 캡슐화를 사용한다.

**40p**
```
C++ 컴파일러는 기술적인 이유로 클래스의 멤버 변수를 해당 클래스의 헤더 파일에 선언할 섯을 요구했다.
이제 point.h 헤더 파일을 사용하는 측에서는 멤버 변수를 알게 되었다.
이로써 캡슐화가 깨졌다.
자바와 C#은 헤더와 구현체를 분리하는 방식을 모두 버렸고, 이로 인해 캡슐화는 더욱 심하게 훼손되었다.
이들 언어에서는 클라스 선언과 정의를 구분하는게 아예 불가능하다.
__언어가 캡슐화를 거의 강제하지 않는다.
...
__ 프로그래밍은 프로그래머가 충분히 올바르게 해동함으로써 캡술화된 데이터를 우회적해서 사용하지 않을 거라는 믿음을 기반으로 한다.
하지만 __를 제공한다고 주장한 언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 약화시캬 온것은 틀림없다.
```
Q1. 여기서 말한 완벽환 캡슐화란?

### 상속?
말할 내용 : 왜 상속도 __를 정의하는 요소가 되지 못하는가

```
__언어가 더 나은 캡슐화를 제공하지는 못했지만, 상속은 확실히 제공했다.
상속이란 다순히 어떤 변수와 함수를 하나의 유효번위로 묶어서 재정의하는 일에 불과하다.
C 프로그래머는 언어의 도움 없이 손수 이러한 방식을 구현할 수 있었다.
```

**42p**
```
main 프로그램을 잘 살펴보면 NamedPoint 데이터 구조가 마치 Point 데이터 구조로부터 파생된 구조인것처럼 동작한다는 사실을 볼 수 있다.
이는 NamedPoint에 선언된 두 변수의 순서가 Point와 동일하기 떄문이다.
...
여튼 C++은 이렇게 단일 상속을 구현해서 썼다.
따라서 __언어가 고안되기 훨씬 이전에도 상속과 비슷한 기법이 사용되었다.
흉내내는 요령은 있었지만, 상속만큼 편하지는 않았다.
또한 업캐스팅이 암묵적으로 이루어진다.
```
Q1. 이거 상속으로 다들 보이나? 위에서 말한 상속은 재정의라 말했는데 이건 다형성 아닌가?


### 다형성?
말할 내용 : 다형성도 __를 정의하는 요소가 되지 못할까?

```
__언어 이전에도 다형성을 표현할 수 있는 언어가 있었다.
```

**44p**
```
위 copy() 함수는 다형적이다. 즉, 행위가 STDIN과 STDOUT에 의존한다.
...
STDIN과 STDOUT도 사실상 인터페이스로 따로 구현체가 있다.
그럼 어떻게 장치 드라이버를 호출할 수 있을까?
유닉스 운영체제의 경우 모든 입출력 장치 드라이버가 다섯 사지 표준 함수를 제공할 것을 요구한다.
FILE 데이터 구조는 이들 함수를 가리키는 포인터들을 포함한다
```

**45p**
```
드라이버에서는 이들 함수를 이렇게 정의하고 함꼐 로드한다.
...
★다시 말해 getchar()는 STDIN으로 참조되는 FILE 데이터 구조의 read 포인터가 가르키는 함수를 단순히 호출할 뿐이다.
이처럼 단순한 기법이 모든 __를 지닌 다형성의 근간이 된다.
...
★함수를 가르키는 포인터를 응용한 것이 다형성이라는 점이다.
함수에 대한 포인터를 직접 사용하여 다형적 행위는 문제가 있을 수 있다.(init,...)
__언어는 이러한 관례를 없애주며, 따라서 실수할 위험이 없다.
```

#### 다형성이 가지는 힘
```
새로운 입출력 장치가 생긴다면 프로그램에서는 어떤 변화가 생기는가?
...
아무 변경도 필요하지 않다.
입출력 드라이버가 FILE에 정의된 다섯 가지 표준 함수를 구현한다면, 복사 프로그램에서는 이 입출력 드라이버를 얼마든지 사용할 수 있다.
다시 말해 입출력 드라이버가 복사 프로그램의 플러그인이 된 것이다.
...
플러그인 아키텍처는 이처럼 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.
```

#### 의존성 역적

```
다형성의 매커니즘 전에는 소스 코드 의존성의 방향은 반드시 제어흐름을 따르게 된다.
...
하지만 다형성이 끼어들면 무언가 특별한 일이 일어난다.
```

**49**

```
1. HL 모듈은 ML 모듈의 F()함수를 호출한다.
2. 소스코드에서는 HL 모듈은 인터페이스를 통해 F()함수를 호출한다.
이 인터페이스는 런타임에는 존재하지 않는다.
...
하지만 ML과 I 인터페이스 사이의 소스 코드 의존성이 제어 흐름과 반대인 점에 주목하자.
이는 의존성 역적 이라고 부르며, SW arch고나점에서 이러한 현상은 심오한 의미를 가진다.
★ 소스 코드 의존성은 소스코드 사이에 인터페이스를 추가함으로써 방향을 역전시킬 수 있다.
```
★ __란 다형성을 이용하여 전체 시스템의 모든 소스코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.

---------------------------------------

## 함수형 프로그래밍
```
함수형 프로그래밍이라는 개념은 ... 핵심이 되는 기반은 람다 계산법으로 부터 나왔다.
```

### 정수를 제곱하기
- 함수형 언어에서 변수는 변경되지 않는다.


### 불변성과 아키텍처
```
아키텍처를 고려할 때 이러한 내용이 왜 중요한가?
race, deadlock, concurrent 문제가 모두 가변 변수로 인해 발생하기 떄문이다.
...
불변성은 실현 가능하겠지만 일종의 타협을 해야한다.
```


### 가변성의 분리
```
... 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.
불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며,
어떤 가변 변수도 사용되지 않는다.
불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다.
...
상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜젝션 메모리를 사용한다...
```
- ex) 클로저의 atom 기능


```
말하려는 요지는, 애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야한다는 것이다.
그리고 이렇게 분리하려면 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야한다.
```

### 이벤트 소싱
```
그냥 트랜잭션 자체를 저장해보자. 이러면 가변 변수가 필요가 없다.
...
이벤트 소싱에 깔려 있는 기본 발상이 바로 이것이다. 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다.
```


## 결론
```
구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
...
즉, 소프트웨어는 급격히 발전하는 기술이 아니라는 진실과 마주하게 된다.
```
★ 프로그램은 순차, 분기, 반복으로 구성된다.
























